---
# draft: true

categories:
  - coding
tags:
  - js
date: 2021-03-27
title: 面试题!
---

## 前言

记录面试过程遇到的各种面试题

## 计算属性和 wacht 的区别？

### computed

当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性。
计算属性存在缓存，当 data 中数据没有发生改变时，我们调用 computed 中函数 n 次，只会进行缓存（执行一次）
每个计算属性都包含两个 set、get 属性

### watch

当数据变化时执行异步或开销较大的操作，可以随时修改状态的变化
watch:类似于监听机制+事件机制。
在大部分情况下我们都会使用 computed，但如果要在数据变化的同时进行异步操作或者是比较大的开销，那么 watch 为最佳选择

## 如何理解父子组件的通信

1.父组件可以使用 `props` 把数据传给子组件。

2.子组件可以使用 `$emit` 触发父组件的自定义事件。

## 路由有哪些导航状态(路由钩子函数)

1. 进入路由之前的--`router.beforeEach`全局前置守卫,当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 `resolve` 完之前一直处于 等待中

2. `router.beforeRouterEach`调用之后调用--`router.beforeResolve`全局解析守卫

3. `router.afterEach`进入路由之后

## 用原生 js 给按钮 2 个点击事件

用`btn.addEventListener()`来绑定

```js
const btn = document.getElementById("btn");

// 事件监听 绑定多个事件
btn4.addEventListener("click", hello1);
btn4.addEventListener("click", hello2);
function hello1() {
  alert("hello 1");
}
function hello2() {
  alert("hello 2");
}
```

## 前端页面的性能优化

1. 使用图片懒加载技术

2. 使用`CDN`域名进行静态资源加速

3. 减少`HTTP`的请求次数

## vue 如何实现双向绑定的

利用了 `Object.defineProperty()` 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。

## mvvm 框架和 MVC 有和区别

MVC:

1. `View` 传送指令到 `Controller`
2. `Controller` 完成业务逻辑后，要求 `Model` 改变状态
3. `Model` 将新的数据发送到 `View`，用户得到反馈
   所有通信都是单向的。

MVVM:

唯一的区别是，它采用双向绑定（data-binding）：`View`的变动，自动反映在`ViewModel`，反之亦然。`Angular` 和 `Ember` 都采用这种模式。

## new 操作符做了哪些操作

1.创建一个空对象

```js
var obj = new Object();
```

2.设置原型链(当调用构造函数创建一个新实例后，该实例内部将包含一个指针，指向构造函数的原型对象)

```js
obj.__proto = Func.prototype;
```

3.让 Func 的 this 指向 obj,并执行 Fun 函数体。

```js
var result = Func.call(obj);
```

4.判定 Func 的返回类型
如果是值类型，返回 obj。如果是引用类型，就返回这个引用类型对象

```js
if (typeof result == "object") {
  func = result;
} else {
  func = obj;
}
```

## HTTP 协议中，除了 GET 和 POST 还有什么请求？

**1. OPTIONS**

这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用'\*'来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。

**2. HEAD**

与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。

**3. GET**

向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。参见安全方法

**4. POST**

向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

**5. PUT**

向指定资源位置上传其最新内容。

**6. DELETE**

请求服务器删除`Request-URI`所标识的资源。

**7. TRACE**

回显服务器收到的请求，主要用于测试或诊断。

**8. CONNECT**

HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）。

## 直接给一个数组项赋值，Vue 能检测到变化吗

由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：

- 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
- 当你修改数组的长度时，例如：`vm.items.length = newLength`

为了解决第一个问题，Vue 提供了以下操作方法：

```js
// Vue.set
Vue.set(vm.items, indexOfItem, newValue);
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue);
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue);
```

为了解决第二个问题，Vue 提供了以下操作方法：

```js
// Array.prototype.splice
vm.items.splice(newLength);
```

## keep-alive 是什么

::: tip
`keep-alive`是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；使用 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
:::
**一个场景**

用户在某个列表页面选择筛选条件过滤出一份数据列表，由列表页面进入数据详情页面，再返回该列表页面，我们希望：列表页面可以保留用户的筛选（或选中）状态。
`keep-alive`就是用来解决这种场景。当然`keep-alive`不仅仅是能够保存页面/组件的状态这么简单，它还可以避免组件反复创建和渲染，有效提升系统性能。总的来说，`keep-aliv`e 用于保存组件的渲染状态。

## CDN 是什么？

将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。

解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。

## import 和 require 的区别

### 遵循规范

- `require` 是`AMD`规范引入方式

- `import`是`es6`的一个语法标准，如果要兼容浏览器的话必须转化成`es5`的语法

### 调用时间

- `require`是运行时调用，所以`require`理论上可以运用在代码的任何地方

- `import`是编译时调用，所以必须放在文件开头

### 本质

- `require`是赋值过程，其实`require`的结果就是对象、数字、字符串、函数等，再把`require`的结果赋值给某个变量

- `import`是解构过程，但是目前所有的引擎都还没有实现`import`，我们在`node`中使用`babel`支持`ES6`，也仅仅是将`ES6`转码为`ES5`再执行，`import`语法会被转码为`require`

## 使用过 Vue SSR 吗？说说 SSR？

::: tip
`Vue.js` 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。
即：SSR 大致的意思就是`vue`在客户端将标签渲染成的整个 `html` 片段的工作在服务端完成，服务端形成的`html` 片段直接返回给客户端这个过程就叫做服务端渲染。
:::

`SSR`大致的意思就是`vue`在客户端将标签渲染成的整个 `html` 片段的工作在服务端完成，服务端形成的`html` 片段直接返回给客户端这个过程就叫做服务端渲染。

服务端渲染 `SSR` 的优缺点如下：

- 更好的 `SEO`：

因为 `SPA` 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

- 更快的内容到达时间（首屏加载更快）:

`SPA` 会等待所有 `Vue` 编译后的 `js` 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

服务端渲染的缺点：

- 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；

- 更多的服务器负载：在 `Node.js` 中渲染完整的应用程序，显然会比仅仅提供静态文件的 `server` 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。

## 使用 ES6 翻转字符串

```js
let str = "hello world";
console.log([...str].reverse().join(""));
```

## 为什么 router 的 history 模式刷新页面会 404

当使用 history 模式时，URL 就像正常的 url，但是因为 vue-router 设置的路径不是真实存在的路径，所以刷新就会返回 404 错误

想要 history 模式正常访问，还需要后台配置支持。要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
也就是在服务端修改 404 错误页面的配置路径，让其指向到 index.html。

::: warning
这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，我们应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。
:::

```js
const router = new VueRouter({
  mode: "history",
  routes: [{ path: "*", component: NotFoundComponent }],
});
```

如此便解决了页面刷新后 404 问题。

### iis 配置

::: tip
无需安装其他组件，将错误页指向 index.html 即可
:::

```js
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <system.web>
        <customErrors mode="On" defaultRedirect="index.html">
            <error statusCode="404" redirect="index.html" />
        </customErrors>
    </system.web>
    <system.webServer>
        <httpErrors errorMode="Custom">
            <remove statusCode="404" />
            <remove statusCode="500" />
            <error statusCode="500" path="/index.html" responseMode="ExecuteURL" />
            <error statusCode="404" path="/index.html" responseMode="ExecuteURL" />
        </httpErrors>

    </system.webServer>
</configuration>
```

### nginx 配置

::: tip
启动如遇问题尝试使用命令创建/logs/nginx.pid 文件:nginx -c conf/nginx.conf
不要设置环境变量，重启命令：start nginx -s -reload
:::

```js
server {
    listen       3355;
    location / {
        root F:/dist;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
}
```

## http 请求 304 代表什么

2 开头 （请求成功）表示成功处理了请求的状态代码。

3 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

4 开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。

5 开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。、

## vue 修饰符 sync 是干嘛用的？

组件通信的双向绑定

在有些情况下，我们可能需要对一个 `prop` 进行“双向绑定”。为此， 使用 `update:myPropName` 抛出事件。例如，对于在上一个示例中带有 `title prop` 的 `ChildComponent`，我们可以通过下面的方式将分配新 `value` 的意图传达给父级:

```js
this.$emit("update:title", newValue);
```

如果需要的话，父级可以监听该事件并更新本地 data property。例如：

```html
<ChildComponent :title="pageTitle" @update:title="pageTitle = $event" />
```

为了方便起见，我们可以使用 .sync 修饰符来缩写，如下所示：

```html
<ChildComponent :title.sync="pageTitle" />
```

当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。

## 什么是 vuex

vuex 是一个专为应用开发的`状态管理模式`。vuex 应用的`核心就是store(仓库)`，`sotre`基本上就是一个容器，它包含着应用中大部分的`状态(state)`

(1)`vuex的状态是响应式的`。当 vue 的组件从 store 中读取状态的时候，**如果`sotre`的状态发生改变,那么相应的组件状态也会得到高效更新**

(2)**改变 soter 中的状态唯一途径就是显示的提交(commit)mutation**。这样可以方便跟踪每一个状态的变化

主要包括以下几个模块：

- State: 定义了应用状态的数据结构，可以在这里设置默认的初始状态。

- Getter: 允许组件从 `Store` 中获取数据，`mapGetters` 辅助函数仅仅是将 `store` 中的`getter` 映射到局部计算属性。

- Mutation: 是唯一更改 `store` 中状态的方法，且必须是同步函数

- Action: 用于提交 `mutation`，而不是直接变更状态，可以包含任意异步操作

- Module: 允许将单一的 `Store` 拆分为多个 `store` 且同时保存在单一的状态树中

## 在 v-for 中使用 v-if 那个优先级更高些

`v-if` 优先级更高， 会先根据条件判断是否显示内容

## 你有对 Vue 项目进行哪些优化?

(1) 代码层面的优化

- `v-if` 和 `v-show` 区分使用场景

- `computed` 和 `watch` 区分使用场景

- `v-for` 遍历必须为 `item` 添加 `key`，且避免同时使用 `v-if`

- 长列表性能优化

- 事件的销毁

- 图片资源懒加载

- 路由懒加载

- 第三方插件的按需引入

- 优化无限列表性能

- 服务端渲染 SSR or 预渲染

(2)Webpack 层面的优化

- Webpack 对图片进行压缩

- 减少 `ES6` 转为 `ES5` 的冗余代码

- 提取公共代码

- 模板预编译

- 提取组件的 `CSS`

- 优化 `SourceMap`

- 构建结果输出分析

- Vue 项目的编译优化

(3) 基础的 `Web` 技术的优化

- 开启 `gzip` 压缩

- 浏览器缓存

- `CDN` 的使用

- 使用 `Chrome Performance`查找性能瓶颈

## 什么是浅拷贝什么是深拷贝

浅复制只能复制一层对象属性，而深复制复制了所有层级

浅复制`只会将对象的各个属性进行依次复制，并不会进行递归复制`

深复制它不仅将原对象的各个属性逐个复制出去，而且将`原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上`

## 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？

**(1)hash 模式的实现原理**

早期的前端路由是基于 location.hash 来实现的,其原理 location.hash 的值就是 URL#后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：

```html
https://www.word.com#search
```

`hash` 路由模式的实现主要是基于下面几个特性：

- `URL` 中 `hash` `值只是客户端的一种状态`，也就是说当向服务器端发出请求时，`hash` 部分不会被发送；

- `hash` 值的改变，`都会在浏览器的访问历史中增加一个记录`。因此我们能通过浏览器的回退、前进按钮控制 hash 的切换

- `可以通过 a 标签，并设置 href 属性`，当用户点击这个标签后，`URL` 的 `hash` 值会发生改变；或者使用 JavaScript 来对 `loaction.hash` 进行赋值，改变 URL 的 hash 值

- 我们`可以使用 hashchange 事件来监听 hash 值`的变化，从而对页面进行跳转（渲染）

**history 模式的实现原理**

`HTML5` 提供了 `History API` 来实现 URL 的变化。其中做最主要的 API 有以下两个：`history.pushState()` 和 `history.repalceState()`。这两个 `API` 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：

```js
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
```

`history` 路由模式的实现主要基于存在下面几个特性：

- `pushState` 和 `repalceState` 两个 `API` 来操作实现 URL 的变化

- 我们可以使用 `popstate` 事件来监听 `url` 的变化，从而对页面进行跳转（渲染）

- `history.pushState()` 或 `history.replaceState()` 不会触发 `popstate` 事件，这时我们需要手动触发页面跳转（渲染）。

## vue-router 的动态路由是什么，怎么获取传过来的参数

我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件

比如在写商品详情页面的时候，页面结构都一样，只是商品id的不同，所以这个时候就可以用动态路由。动态设置不同商品都对应到一个页面，返回不同的数据
使用 $route.params
## js 的事件循环机制

**进程、线程**

- 进程是系统分配的独立资源，是 CPU 资源分配的基本单位，进程是由一个或者多个线程组成的。

- 线程是进程的执行流，是CPU调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。

**浏览器内核**

浏览器内核有多种线程在工作。

GUI 渲染线程:

- 负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。

- 和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。

JS 引擎线程:

- 单线程工作，负责解析运行 JavaScript 脚本。

- 和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。

事件触发线程:

- 当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。

定时器触发线程:

- 浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。

- 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。

http 请求线程:

- http 请求的时候会开启一条请求线程。

- 请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。

js是单线程语言，在同一时刻只能处理一个任务。js可以使用setTimeout,ajax,promise,mutationObserver模拟多线程。 我们可以使用异步代码进

行多线程编码开发。

**JavaScript 事件循环机制**

JavaScript 事件循环机制分为浏览器和 Node 事件循环机制

Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

- JS 调用栈

JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。

- 同步任务、异步任务

JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。

- Event Loop

调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。

- 定时器

定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。

定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。

- 宏任务(macro-task)、微任务(micro-task)

除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。

macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。

micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。

## 什么是 js 的事件委托

事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

**事件委托原理**

`事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件`，举个例子：页面上有这么一个节点树，`div>ul>li>a`; 比如给最里面的 a 加一个 `click` 点击事件，那么这个事件就会一层一层的往外执行，执行顺序 `a>li>ul>div`，有这样一个
机制，那么我们给最外面的 `div` 加点击事件，那么里面的 `ul，li，a` 做点击事件的时候，都会冒泡到最外层的 `div` 上，所以都会触发，这就是事

件委托，委托它们父级代为执行事件

## Cookie sessionStorage localStorage

**共同点**：

都是保存在浏览器端，且同源的

**区别**：

`cookie`数据始终在同源的`http`请求中携带，即`cookie`在浏览器和服务器间来回传递。而`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。

**大小**：

`cookie`数据不能超过 4k(适合保存小数据), `sessionStorage`和`localStorage`容量较大

**数据有效期不同**:

`sessionStorage`仅在当前浏览器窗口关闭前有效

`localStorage`始终有效，窗口或浏览器关闭也一直保存，需手动清除

`cookie`只在设置的`cookie`过期时间之前一直有效，即使窗口或浏览器关闭

**作用域不同**

`sessionStorage`不在不同的浏览器窗口中共享

`localStorage` 在所有同源窗口中都是共享的；`cookie`也是在所有同源窗口中都是共享的


## 数组转为树结构
``` js
 var data = [

  { id: 1, name: "办公管理", pid: 0 },

  { id: 2, name: "请假申请", pid: 1 },

  { id: 3, name: "出差申请", pid: 1 },

  { id: 4, name: "请假记录", pid: 2 },

  { id: 5, name: "系统设置", pid: 2 },

  { id: 6, name: "权限管理", pid: 5 },

  { id: 7, name: "用户角色", pid: 6 },

  { id: 8, name: "菜单设置", pid: 6 },

  { id: 9, name: "请假记录", pid: 4 },

];

function toTree(data) {

  // 删除所有 children,以防止多次调用
  data.forEach(function(item) {

    delete item.children;

  });


  // 将数据存储为 以 id 为 KEY 的 map 索引数据列

  var map = {};

  data.forEach(function(item) {

    map[item.id] = item;

  });



  var val = [];

  data.forEach(function(item) {

    // 以当前遍历项的pid,去map对象中找到索引的id

    var parent = map[item.pid];

    // 如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中

    if (parent) {

      (parent.children || (parent.children = [])).push(item);

    } else {

      //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级

      val.push(item);

    }

  });

  console.log(val)

  return val;

}

toTree(data)
```
