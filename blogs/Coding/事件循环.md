---
top: 1
categories:
  - coding
tags:
  - js
date: 2022-06-10
title: 事件循环机制
img: https://www.zpzpup.com/assets/image/gd08.jpg
---

## 事件循环基础

**宏任务:** script(整体代码)，setTimeout,setInterval,setImmediate,I/O,UI rendring
=
**微任务:** promise,object.observe,MuationObserver

任务的优先级：process.nextTick > promise.then > setTimeout > setImmediate


新程序执行归为宏任务，宏任务优先于微任务执行，代码执行到一个微任务就添加到微任务栈。调用栈被清空以后事件循环会优先寻找微任务队列里面的任务，每次宏

任务结束后事件循环就会先执行微任务，直到微任务队列被清空才会执行下一轮宏任务。并不会宏任务全部执行了再执行微任务

## 浏览器的多线程

### 1.GUI 渲染线程

- 绘制页面，解析HTML、CSS、创建DOM树，布局和绘制等

- 页面重绘和回流

- 与JS引擎线程互斥、也就是所谓的JS执行阻塞页面更新

### 2.JS引擎线程

- 负责JS脚本代码的执行

- 负责准执行准备好待执行的事件，即定时器计数结束，或是异步请求成功正确返回的事件

- 与GUI渲染线程互斥，执行时间过长将阻塞页面的渲染

### 3.事件触发线程

- 负责将准备好的事件交给JS引擎线程执行

- 多个事件加入任务队列的时候需要排队等待(JS的单线程)

### 4.定时器触发线程

- 负责执行异步的定时器类的事件，如setTiemout、setInterval

- 定时器到时间之后把注册的回调加入到任务列的队尾

### 5.HTTP请求线程

- 负责执行异步请求

- 主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调加入到任务队列的队尾等待执行

## JavaScript 事件循环机制

JavaScript 事件循环机制分为浏览器和 Node 事件循环机制

Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

- JS 调用栈

JS 调用栈是一种先进后出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。

- 同步任务、异步任务

JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。

- Event Loop

调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。

- 定时器

定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。

定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。

- 宏任务(macro-task)、微任务(micro-task)

除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。

macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。

micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。


在实际的生产应用中会涉及到多个容器，容器为什么必须跨越多个主机进行部署。

## 基本概念通俗解释
- 想象一下餐厅的运作模式：

- 调用栈（Call Stack） - 相当于厨师

一次只能做一件事

按顺序处理任务
处理同步代码

- 任务队列（Task Queue/Callback Queue） - 相当于等待区
存放准备执行的异步任务
比如点餐单、顾客的要求等

- 微任务队列（Microtask Queue） - 相当于VIP等待区

优先级更高的任务

Promise的回调会进入这里

工作流程举例
``` javascript 
console.log('点餐'); // 1

setTimeout(() => {
    console.log('炒菜需要3秒'); // 4
}, 3000);

Promise.resolve().then(() => {
    console.log('先上茶水'); // 2
});

console.log('收钱'); // 3
```
执行顺序解释：
"点餐" - 立即执行
setTimeout进入普通任务队列
Promise的then进入微任务队列
"收钱" - 立即执行
检查微任务队列，执行"先上茶水"
3秒后，执行"炒菜需要3秒"
事件循环的基本规则
同步优先
先执行所有同步代码
微任务插队
同步代码执行完后，立即检查微任务队列
执行所有微任务
宏任务排队
微任务清空后，才执行宏任务
setTimeout、setInterval等属于宏任务
常见的任务类型
微任务（Microtasks）：
Promise.then/catch/finally
process.nextTick (Node.js)
MutationObserver
宏任务（Macrotasks）：
setTimeout/setInterval
事件回调
AJAX请求
I/O操作
实际应用示例
``` javascript

console.log('点餐'); // 1

setTimeout(() => {
    console.log('炒菜需要3秒'); // 4
}, 3000);

Promise.resolve().then(() => {
    console.log('先上茶水'); // 2
});

console.log('收钱'); // 3
```
## 注意事项

零延时不等于立即执行

`setTimeout(fn, 0)` 不会立即执行

仍然要等待当前同步代码和微任务执行完

微任务优先级

微任务总是比宏任务先执行

一个微任务可能产生新的微任务，这些也会立即执行

死循环风险

如果微任务不断产生新的微任务，可能导致宏任务永远无法执行

需要合理控制任务数量

理解事件循环机制对于编写高效的异步代码非常重要，它能帮助我们更好地控制代码执行顺序，优化应用性能


