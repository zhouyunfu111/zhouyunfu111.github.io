---
top: 1
categories:
  - coding
tags:
  - js
date: 2022-06-10
title: 事件循环机制
img: https://www.zpzpup.com/assets/image/gd08.jpg
---

## 事件循环基础

**宏任务:** script(整体代码)，setTimeout,setInterval,setImmediate,I/O,UI rendring

**微任务:** promise,object.observe,MuationObserver

任务的优先级：process.nextTick > promise.then > setTimeout > setImmediate


新程序执行归为宏任务，宏任务优先于微任务执行，代码执行到一个微任务就添加到微任务栈。调用栈被清空以后事件循环会优先寻找微任务队列里面的任务，每次宏

任务结束后事件循环就会先执行微任务，直到微任务队列被清空才会执行下一轮宏任务。并不会宏任务全部执行了再执行微任务

## 浏览器的多线程

### 1.GUI 渲染线程

- 绘制页面，解析HTML、CSS、创建DOM树，布局和绘制等

- 页面重绘和回流

- 与JS引擎线程互斥、也就是所谓的JS执行阻塞页面更新

### 2.JS引擎线程

- 负责JS脚本代码的执行

- 负责准执行准备好待执行的事件，即定时器计数结束，或是异步请求成功正确返回的事件

- 与GUI渲染线程互斥，执行时间过长将阻塞页面的渲染

### 3.事件触发线程

- 负责将准备好的事件交给JS引擎线程执行

- 多个事件加入任务队列的时候需要排队等待(JS的单线程)

### 4.定时器触发线程

- 负责执行异步的定时器类的事件，如setTiemout、setInterval

- 定时器到时间之后把注册的回调加入到任务列的队尾

### 5.HTTP请求线程

- 负责执行异步请求

- 主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调加入到任务队列的队尾等待执行

## JavaScript 事件循环机制

JavaScript 事件循环机制分为浏览器和 Node 事件循环机制

Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

- JS 调用栈

JS 调用栈是一种先进后出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。

- 同步任务、异步任务

JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。

- Event Loop

调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。

- 定时器

定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。

定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。

- 宏任务(macro-task)、微任务(micro-task)

除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。

macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。

micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。



